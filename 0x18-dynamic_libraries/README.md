    0x18.C - Dynamic Libraries

# what is the dynamic library:
    a dynamic library aka shared library is a file containing compiled code and data that can be used by multiple programs at runtime. its designed to be shared and loaded into memory by multiple applications, reducing duplication of code and allowing for more efficient memory usage.

    dynamic library provide a way to modularize code and separate it from main executable file. they offer several advantages:
        code reusablity
        efficient memory usage
        easy updates
        dynamic loading 
# how does it work:
    it work by providing a mechanism for code and data to be shared among multiple programs at runtime. here are the high level overview of how dynamic libraries work
        compilation
        linking
        loading
        symbol resolution
        execution
        uploading
# how to create it:
    1.write the library code: create the source code files (.c)
    2.compile the source code: 
        gcc -c -fPIC library  -o library.o
    3.link object files:
        gcc -shared library1.o library.o -o libmylibrary.so
    4. install the library:
        sudo install libmylibrary.so /usr/local/lib
    5.update library paths:
     
    6.link against the library: 
        gcc myprogram.c -o myprogram -lmylibrary

    these 6 steps are basic to have a dynamic library and use it.

# What is the environment variable $LD_LIBRARY_PATH and how to use it:
    the $LD_LIBRARY_PATH environment variable is a variable used by the os dynamic linker/loader to locate shared libraries at runtime.it specifies addtional directories where the linker should search for shared libraries when executing a program.

    when a program is run the dynamic linker/loader for shared libraries that are reuquired by the program.it searchs in std library paths, such as /lib/ and /usr/lib as well as directories specified in the $LD_LIBRARY_PATH variable
        1, view current value:
            echo $LD_LIBRARY_PATH: 
        2.setting the variable temporarily:
            export LD_LIBRARY_PATH=/path/to/library/directory
        3.setting the variable permanently:
            export ~/.bashrc file
        then it will be set evrytime you start a new terminal session.

# What are the differences between static and shared libraries:

    static libraries:
        - compilation:static libs are created by achiving object files together into a single file, often with the extension file.a .these object files are generated by compiling the source code separately.
        - linking:when a program is compiled and linked against a static library, the entire contents of lib are copied into the final execuatable.this means that the code and data from the static lib become part of the program itself.
        - independence: static libs are self contained , meaning that all the code and dependencies required by the library are included within it.this makes the resulting executable independent of external libs at runtime.
        - memory usage: since the code and the data are in static library are duplicated ion each executable that uses it, it can lead to increased memory usage if multiple programs use the same static library.
        portablity: static libs are generally more portable as they do not rely on external dependencies. the executable can be disturbuted as a single file and executed on differnt systems without worrying about lib compatiblity.
        Updates: When a static library is updated, any programs using that library need to be recompiled and relinked to take advantage of the changes. Each program has its own copy of the library, so updates to the library do not automatically propagate to all programs.

    dynamic libraries:
        - compilation:are compiled into separate files, often with extension (.so) in linux (.dll) in windows
        - linking:when a program is compiled and linked against a shared lib it doesnt include the library code and data in the executable itself.instead, the program references the shared lib symbols and dependencies at runtime.
        - dynamic loading: shared libs are loaded and linked at runtime by the operating system's dynamic linker,loader. this allows multiple programs to share the same lib code in memory, reducing memory usage.
        - memory sharing: since shared libs are loaded once and shared among multiple programs ,they can reduce memory consumption.
        - updates: when shared lib is updated all programs using that library can be potentially benfit from the changes without recompiling or relinking. The updated library can be loaded dynamically, and programs can access the new functionality without requiring any changes to the executable.
        Dependency Management: Shared libraries can have dependencies on other shared libraries. The dynamic linker/loader resolves these dependencies and loads the required libraries automatically.

# Basic usage nm, ldd, ldconfig:
    nm: displays the symbol table infn from object files or libraries.it is used to examine the symbols(function, variables) defined in lib or obj file.
        nm libfile
    ldd: lists the shared libs dependencies of a program or a library. it shows the shared libs required by an executable or shared obj file
        ldd exe_file
    ldconfig: is used to update the cache of shared libs and thier paths. it is typically used after installing and updating shared librries to ensure the dynamic linker/loader can find them.
        sudo ldconfig
        

## Tasks :page_with_curl:

* **0. A library is not a luxury but one of the necessities of life**
  * [libdynamic.so](./libdynamic.so): C dynamic library containing all the functions
  listed below:
    * `int _putchar(char c);`
    * `int _islower(int c);`
    * `int _isalpha(int c);`
    * `int _abs(int n);`
    * `int _isupper(int c);`
    * `int _isdigit(int c);`
    * `int _strlen(char *s);`
    * `void _puts(char *s);`
    * `char *_strcpy(char *dest, char *src);`
    * `int _atoi(char *s);`
    * `char *_strcat(char *dest, char *src);`
    * `char *_strncat(char *dest, char *src, int n);`
    * `char *_strncpy(char *dest, char *src, int n);`
    * `int _strcmp(char *s1, char *s2);`
    * `char *_memset(char *s, char b, unsigned int n);`
    * `char *_memcpy(char *dest, char *src, unsigned int n);`
    * `char *_strchr(char *s, char c);`
    * `unsigned int _strspn(char *s, char *accept);`
    * `char *_strpbrk(char *s, char *accept);`
    * `char *_strstr(char *haystack, char *needle);`

  * [main.h](./main.h): Header file containing the prototypes of all functions
  included in `libdynamic.so`.

* **1. Without libraries what have we? We have no past and no future**
  * [1-create_dynamic_lib.sh](./1-create_dynamic_lib.sh): Bash script that creates a
  dynamic library called `liball.so` from all the `.c` files in the current directory.

* **2. Let's call C functions from Python**
  * [100-operations.so](./100-operations.so): C dynamic library containing basic C
  mathematical operation functions that can be called from Python.
  * Includes:
    * `int add(int a, int b);`
    * `int sub(int a, int b);`
    * `int mul(int a, int b);`
    * `int div(int a, int b);`
    * `int mod(int a, int b);`